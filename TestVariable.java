public class TestVariable{
	
	/*-----------
		3 TYPES OF VARIABLES :
							1) INSTANCE VARIABLE
							2) STATIC VARIABLE
							3) LOCAL VARIABLE
	-----------*/
	
	
	/*-----------
		2 TYPES OF METHODS :
							1) INSTANCE METHOD
							2) STATIC METHOD
	-----------*/
	
	
	/*-----------
		2 TYPES OF CLASS AREA :
							1) INSTANCE AREA
							2) STATIC AREA
	-----------*/
	
	
	
	/*----------- 1) INSTANCE VARIABLE -----------*/
	
	// 1. INSTANCE VARIABLES ARE ALSO KNOWN AS ATTRIBUTES OR OBJECT LEVEL VARIABLES 
	// 2. VALUE OF INSTANCE VARIABLE VARIES FROM OBJECT TO OBJECT
	// 3. FOR EVERY OBJECT, A SEPERATE COPY OF INSTANCE VARIABLE WILL BE CREATED
	// 4. INSTANCE VARIABLES ARE DECLEARED WITHIN THE CLASS, BUT OUTSIDE OF ANY METHOD OR BLOCK OR CONSTRUCTOR
	// 5. INSTANCE VARIABLE WILL BE CREATED AT THE TIME OF OBJECT CREATION, AND DESTROYED AT THE TIME OF OBJECT DESTRUCTION 	
	// 6. THE SCOPE OF INSTANCE VARIABLE IS EXACTLY SAME AS THE SCOPE OF THE OBJECT
	// 7. INSTANCE VARIABLES WILL BE STORED AT THE HEAP MEMORY AS A PART OF OBJECT
	// 8. INSTANCE VARIABLE IS NOT REQUIRED TO PERFORM INITIALIZATION EXPLICITELY, JVM WILL PROVIDE DEFAULT VALUE 
	// 9. SAME INSTANCE VARIABLE CAN BE ACCESSED BY MULTIPLE THREADS, HENCE INSTANCE VARIABLES ARE NOT THREAD SAFE
	
	// 10. INSTANCE VARIABLE CAN BE ACCESSED DIRECTLY FROM INSTANCE AREA
	// 11. INSTANCE VARIABLE CAN BE ACCESSED BY OBJECT REFERENCE FROM STATIC AREA 
	
	int x1;
	boolean b1;
	double d1;
	String s1;
	
	int m1 = 10;
	
	
	
	/*----------- 2) STATIC VARIABLE -----------*/
	
	// 1. STATIC VARIABLES ARE ALSO KNOWN AS FIELDS OR CLASS LEVEL VARIABLES 
	// 2. VALUE OF STATIC VARIABLE DOESN'T CHANGES FROM OBJECT TO OBJECT
	// 3. A SINGLE COPY OF STATIC VARIABLE WILL BE CREATED AT THE CLASS LEVEL, AND EVERY OBJECT WILL SHARE THE SAME COPY
	// 4. STATIC VARIABLES ARE DECLEARED WITH A STATIC KEYWORD WITHIN THE CLASS, BUT OUTSIDE OF ANY METHOD OR BLOCK OR CONSTRUCTOR 
	// 5. STATIC VARIABLE WILL BE CREATED AT THE TIME OF CLASS LOADING, AND DESTROYED AT THE TIME OF CLASS UNLOADING 	
	// 6. THE SCOPE OF STATIC VARIABLE IS EXACTLY SAME AS THE SCOPE OF THE DOT CLASS FILE
	// 7. STATIC VARIABLES WILL BE STORED AT THE METHOD AREA
	// 8. STATIC VARIABLE IS NOT REQUIRED TO PERFORM INITIALIZATION EXPLICITELY, JVM WILL PROVIDE DEFAULT VALUE 
	// 9. THE SAME STATIC VARIABLE CAN BE ACCESSED BY MULTIPLE THREADS, HENCE STATIC VARIABLES ARE NOT THREAD SAFE
	
	// 10. INSIDE THE CLASS, STATIC VARIABLE CAN BE ACCESSED DIRECTLY FROM BOTH THE AREAS (STATIC & INSTANCE) 
	// 11. OUTSIDE THE CLASS, STATIC VARIABLE CAN BE ACCESSED EITHER BY CLASSNAME REFERENCE OR BY OBJECT REFERENCE, CLASSNAME REFERENCE IS RECOMENDED  
	
	static int x2;
	static boolean b2;
	static double d2;
	static String s2;
	
	static int m2 = 20;
	
	
	
	
	
	public static void main(String[] args){ // ____START OF STATIC METHOD AREA____
	
		
		/*----------- 3) LOCAL VARIABLE -----------*/
	
		// 1. LOCAL VARIABLES ARE ALSO KNOWN AS TEMPORARY OR STACK OR AUTOMATIC VARIABLES 
		// 2. N/A
		// 3. N/A
		// 4. LOCAL VARIABLES ARE DECLEARED INSIDE OF ANY METHOD OR BLOCK OR CONSTRUCTOR
		// 5. LOCAL VARIABLE WILL BE CREATED AT THE TIME OF EXECUTION OF THE BLOCK, AND DESTROYED AS THE BLOCK EXECUTION COMPLETES 	
		// 6. THE SCOPE OF LOCAL VARIABLE IS EXACTLY SAME AS THE SCOPE OF THE BLOCK
		// 7. LOCAL VARIABLES WILL BE STORED INSIDE STACK MEMORY 
		// 8. LOCAL VARIABLE IS REQUIRED TO PERFORM INITIALIZATION EXPLICITELY, JVM WILL NOT PROVIDE DEFAULT VALUE 
		// 9. A SEPERATE COPY OF LOCAL VARIABLE WILL BE CREATED FOR EVERY THREAD, HENCE LOCAL VARIABLES ARE THREAD SAFE
	
		// 10. LOCAL VARIABLE CAN BE ACCESSED DIRECTLY ONLY INSIDE THE BLOCK IN WHICH IT IS DECLEARED
		// 11. LOCAL VARIABLE DOESN'T EXISTS OUTSIDE OF THE BLOCK IN WHICH IT IS DECLEARED
		
		int x3 = 5;
		boolean b3 = true;
		double d3 = 5.5;
		String s3 = "asdf";
		
		System.out.println(x3); // OUTPUT : 5 		(DIRECT ACCESS)
		System.out.println(b3); // OUTPUT : true	(DIRECT ACCESS)
		System.out.println(d3); // OUTPUT : 5.5		(DIRECT ACCESS)
		System.out.println(s3); // OUTPUT : asdf 	(DIRECT ACCESS)
		
		
		
		// TO ACCESS INSTANCE VARIABLES :
		
		TestVariable t1 = new TestVariable(); //OBJECT CREATION
		System.out.println(t1.x1); // OUTPUT : 0        (OBJECT REFERENCE)
		System.out.println(t1.b1); // OUTPUT : false	(OBJECT REFERENCE)
		System.out.println(t1.d1); // OUTPUT : 0.0		(OBJECT REFERENCE)
		System.out.println(t1.s1); // OUTPUT : null		(OBJECT REFERENCE)
		
		
		// TO ACCESS STATIC VARIABLES :
		
		System.out.println(x2); // OUTPUT : 0 		(DIRECT ACCESS)
		System.out.println(b2); // OUTPUT : false	(DIRECT ACCESS)
		System.out.println(d2); // OUTPUT : 0.0		(DIRECT ACCESS)
		System.out.println(s2); // OUTPUT : null	(DIRECT ACCESS) 
		
		System.out.println(TestVariable.x2); // (CLASSNAME REFERENCE)
		System.out.println(TestVariable.b2); // (CLASSNAME REFERENCE)
		System.out.println(TestVariable.d2); // (CLASSNAME REFERENCE)
		System.out.println(TestVariable.s2); // (CLASSNAME REFERENCE)
		
		TestVariable t2 = new TestVariable(); //OBJECT CREATION
		System.out.println(t2.x2); // (OBJECT REFERENCE) 
		System.out.println(t2.b2); // (OBJECT REFERENCE)
		System.out.println(t2.d2); // (OBJECT REFERENCE)
		System.out.println(t2.s2); // (OBJECT REFERENCE)
		
		
		// TO CHANGE VALUE OF INSTANCE AND STATIC VARIABLE :
		
		TestVariable t3 = new TestVariable();
		t3.m1 = 888;
		t3.m2 = 999;
		System.out.println(t3.m1); // OUTPUT : 888
		System.out.println(t3.m2); // OUTPUT : 999
		
		TestVariable t4 = new TestVariable();
		System.out.println(t4.m1); // OUTPUT : 10	(2 DIFFERENT COPY OF INSTANCE VARIABLE FOR 2 OBJECTS t3 & t4)
		System.out.println(t4.m2); // OUTPUT : 888	(THE SAME COPY OF STATIC VARIABLE HAS BEEN SHEARED BY 2 DIFFERENT OBJECTS t3 & t4)
		
		
		
		// TO CALL A NON STATIC (INSTANCE) METHOD :
		
		// myMethod(); 		NOT VALID 	(NON STATIC METHOD CAN NOT BE REFERENCED DIRECTLY FROM STATIC AREA)
		t1.myMethod(); // 	VALID 		(OBJECT REFERENCE)
		t2.myMethod(); // 	VALID		(OBJECT REFERENCE)
		t3.myMethod(); // 	VALID		(OBJECT REFERENCE)
		t4.myMethod(); // 	VALID		(OBJECT REFERENCE)
		
	} 	// ____END OF STATIC METHOD AREA____
	
	
	
	
	public void myMethod (/* METHOD PARAMETER (LOCAL VARIABLE)*/) { // ____START OF INSTANCE METHOD AREA____
		
		// TO ACCESS INSTANCE VARIABLES :
		
		System.out.println(x1); //  (DIRECT ACCESS)
		System.out.println(b1); // 	(DIRECT ACCESS)
		System.out.println(d1); // 	(DIRECT ACCESS)
		System.out.println(s1); // 	(DIRECT ACCESS)
		
		TestVariable t5 = new TestVariable(); //OBJECT CREATION
		System.out.println(t5.x1); //  	(OBJECT REFERENCE)
		System.out.println(t5.b1); // 	(OBJECT REFERENCE)
		System.out.println(t5.d1); // 	(OBJECT REFERENCE)
		System.out.println(t5.s1); // 	(OBJECT REFERENCE)
		
		
		
		// TO ACCESS STATIC VARIABLES :
		
		System.out.println(x2); // 	(DIRECT ACCESS)
		System.out.println(b2); // 	(DIRECT ACCESS)
		System.out.println(d2); // 	(DIRECT ACCESS)
		System.out.println(s2); // 	(DIRECT ACCESS) 
		
		System.out.println(TestVariable.x2); // (CLASSNAME REFERENCE)
		System.out.println(TestVariable.b2); // (CLASSNAME REFERENCE)
		System.out.println(TestVariable.d2); // (CLASSNAME REFERENCE)
		System.out.println(TestVariable.s2); // (CLASSNAME REFERENCE)
		
		TestVariable t6 = new TestVariable(); //OBJECT CREATION
		System.out.println(t6.x2); // (OBJECT REFERENCE) 
		System.out.println(t6.b2); // (OBJECT REFERENCE)
		System.out.println(t6.d2); // (OBJECT REFERENCE)
		System.out.println(t6.s2); // (OBJECT REFERENCE)
		
		
		
		
	}	// ____END OF INSTANCE METHOD AREA____
	
}